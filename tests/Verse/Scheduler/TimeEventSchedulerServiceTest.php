<?php


namespace Run\RequestRouter;


use App\Done\Controller\Done;
use App\Item\Controller\All;
use App\Item\Controller\EditMode;
use App\Landing\Controller\Landing;
use PHPUnit\Framework\TestCase;
use Verse\Run\RunContext;
use Verse\Run\RunCore;
use Verse\Run\RuntimeLog;
use Verse\Scheduler\Mock\MockProcessor;
use Verse\Scheduler\Provider\StorageTimeEventsProvider;
use Verse\Scheduler\Service\TimeEventScheduler;
use Verse\Scheduler\Storage\EventsStorage;
use Verse\Telegram\Run\RequestRouter\ResourceCompiler;

class TimeEventSchedulerServiceTest extends TestCase
{
    public static function setUpBeforeClass(): void
    {
        $path = explode(DIRECTORY_SEPARATOR, getcwd());
        $key = array_search('tests', $path);
        if ($key) {
            $path = array_slice($path, 0, $key+1);
            chdir(implode(DIRECTORY_SEPARATOR, $path));
        }

        parent::setUpBeforeClass();
    }

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub

        $service = new TimeEventScheduler();
        // clear events
        $events = $service->getEventStorage()->search()->find([], 10000, __METHOD__);
        $ids = array_column($events, 'id');
        $service->getEventStorage()->write()->removeBatch($ids, __METHOD__);

        // clear time slots
        $events = $service->getTimeSlotStorage()->search()->find([], 10000, __METHOD__);
        $ids = array_column($events, 'id');
        $service->getTimeSlotStorage()->write()->removeBatch($ids, __METHOD__);
    }


    public function testWriteOneEvent()
    {
        $service = new TimeEventScheduler();

        $time = time();
        $route = '/blabla';
        $data = ['bara' => 'data'];
        $user = 'agent007';
        $ttl = 3600;
        $result = $service->addEvent($user, $time, $route, $data, $ttl);
        $this->assertTrue($result);

        $events =$service->getEventStorage()->search()->find([], 10, __METHOD__);
        $this->assertCount(1, $events);
        $event = array_pop($events);

        $this->assertEquals($time, $event[EventsStorage::TIME]);
        $this->assertEquals($route, $event[EventsStorage::ROUTE]);
        $this->assertEquals($data, $event[EventsStorage::DATA]);
        $this->assertEquals($user, $event[EventsStorage::USER]);
        $this->assertEquals($ttl, $event[EventsStorage::TTL]);
    }

    public function testStorageTimeEventProvider()
    {
        $core = new RunCore();
        $context = new RunContext();
        $runtime = new RuntimeLog();
        $core->setContext($context);
        $core->setRuntime($runtime);

        $provider = new StorageTimeEventsProvider();
        $a = new \stdClass();
        $a->loops = 3;

        $provider->setShouldProceedCallback(function () use ($a) {
            return --$a->loops > 0;
        });

        $core->setProvider($provider);

        $processor = new MockProcessor();
        $core->setProcessor($processor);

        $core->configure();
        $core->prepare();
        $core->run();

        $this->assertEquals(0, $a->loops);
    }

    public function testStorageTimeEventProviderWriteAndReadEvent()
    {
        $core = new RunCore();
        $context = new RunContext();
        $runtime = new RuntimeLog();
        $core->setContext($context);
        $core->setRuntime($runtime);

        $provider = new StorageTimeEventsProvider();
        $a = new \stdClass();
        $a->loops = 3;

        $provider->setShouldProceedCallback(function () use ($a) {
            return --$a->loops > 0;
        });

        $core->setProvider($provider);

        $processor = new MockProcessor();
        $core->setProcessor($processor);

        $core->configure();
        $core->prepare();

        $service = new TimeEventScheduler();
        $time = time();
        $route = '/blabla';
        $data = ['bara' => 'data'];
        $user = 'agent007';
        $ttl = 3600;
        $result = $service->addEvent($user, $time, $route, $data, $ttl);
        $this->assertTrue($result);

        $core->run();

        $this->assertEquals(0, $a->loops);
        $req = $processor->getLastRequest();

        $this->assertEquals($route, $req->getResource());
        $this->assertEquals($data, $req->data);
        $this->assertEquals($user, $req->getParamOrData('from', )['user_id']);
    }

    public function testStorageTimeEventProviderWriteAndReadSeveralEvents()
    {
        $core = new RunCore();
        $context = new RunContext();
        $runtime = new RuntimeLog();
        $core->setContext($context);
        $core->setRuntime($runtime);

        $provider = new StorageTimeEventsProvider();
        $a = new \stdClass();
        $a->loops = 3;

        $provider->setShouldProceedCallback(function () use ($a) {
            return --$a->loops > 0;
        });

        $core->setProvider($provider);

        $processor = new MockProcessor();
        $core->setProcessor($processor);

        $core->configure();
        $core->prepare();

        $service = new TimeEventScheduler();

        $createEventsCount = 3;
        $startTime = time();
        for ($i = $createEventsCount - 1; $i >= 0 ; $i--) {
            $time = $startTime - 10*$i;
            $route = '/test_resource';
            $data = ['data' => 'borodata', 'time' => microtime(1), ];
            $user = 'agent007:'.crc32(microtime(1));
            $ttl = 3600;
            $result = $service->addEvent($user, $time, $route, $data, $ttl);
            $this->assertTrue($result);
        }

        $core->run();

        $this->assertEquals(0, $a->loops);
        $req = $processor->getLastRequest();

        $this->assertEquals($route, $req->getResource());
        $this->assertEquals($data, $req->data);
        $this->assertEquals($user, $req->getParamOrData('from', )['user_id']);
        $this->assertCount($createEventsCount, $processor->getAllRequests());
    }
}